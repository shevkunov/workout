\documentclass{article}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{fancyhdr}
\usepackage[english,russian]{babel}
\usepackage{lastpage} 

\pagestyle{fancy} %очистим хидер на всякий случай
\fancyhead[L]{Задача о рюкзаке} 
\fancyhead[C]{Шевкунов К.С. 594} 
\fancyhead[R]{Страница \thepage{}  из \pageref{LastPage}} 
\fancyfoot{} %футер будет пустой

% \usepackage{algorithm}
% \usepackage{algpseudocode}

% \theoremstyle{plain}
\newtheorem{theorem}{Теорема} % reset theorem numbering for each chapter
% \ref{t1}

% \theoremstyle{definition}
\newtheorem{definition}{Определение} % definition numbers are dependent on theorem numbers
\newtheorem{example}{Пример}


\usepackage{comment}


\title{Задача о рюкзаке}
\author{Шевкунов К.С. 594}


\begin{document}


\maketitle

\begin{comment}
\section{Постановка задачи}
	\subsection{Формулировка условия}
	\subsection{Цель}
	\subsection{Доказательство NP-полноты}

\section{Псевдополиномиальное решение}
	\subsection{Алгоритм}
	\subsection{Доказательство}
		 
\section{Полиномиальное приближение}
	\subsection{Алгоритм}
	\subsection{Доказательство}
	\subsection{Работа на реальных данных}
\end{comment}



\section{Постановка задачи}

	\subsection{Формулировка условия}

% TODO : переписать условие, чтобы не было мучительно больно 

Имеется набор из $n$ предметов. У каждого предмета есть положительный вес $w$ и стоимость $c$. Также дано неотрицательное число $W$ — вместимость рюкзака.
Требуется найти такое подмножество предметов $M$, чтобы оно помещалось в рюкзак, и суммарная стоимость предметов была максимальна. То есть:

$$\sum\limits_{x \in M} {w(x)} \leq W, \sum\limits_{x \in M} {c(x)} \rightarrow max$$ 

	\subsection{Цель}

Постройте полиномиальную схему приближения для данной задачи. То есть необходимо придумать и реализовать алгоритм, который получает на вход экземпляр задачи о рюкзаке, а также произвольное (рациональное) $\varepsilon > 0$, и находит $(1 + \varepsilon)$ - приближенное решение. Алгоритм должен работать за полиномиальное время относительно размера исходной задачи и $\frac{1}{\varepsilon}$.

	\subsection{Доказательство NP-трудности}
 
Определим задачу: $$SUBSET-SUM = \{(n_1 , . . . , n_k , N ) | \exists \alpha \in \{0, 1\}^k : \sum\limits_{i = 1}^{k} {\alpha_i n_i} = N \}$$  

В книге (Д.В. Мусатов, "Сложность вычислений. Конспект лекций") дока
Конспект лекций) доказано, что задача $SUBSET-SUM$ является NP-полной. Сведём эту задачу полиномиальной к нашей и этим докажем, что она является NP-трудной. 
 
Обозначим предметы натуральными числами $1 .. N$. Определим $\forall i \in \{1..N\} : c(i) := w(i) := n_i$, $W := N$ Тогда исходная задача свелась к поиску $M$ такого, что:

$$\sum\limits_{x \in M} {n_i} \leq N, \sum\limits_{x \in M} {n_i} \rightarrow max$$ 
 
Или, иначе говоря к задаче поиска $\alpha \in \{0, 1\}^k$, такого, что:

$$\sum\limits_{i = 1}^{k} {\alpha_i n_i} \leq N, \sum\limits_{i = 1}^{k} {\alpha_i n_i} \rightarrow max \leq N$$ 

Ясно, что искомый максимум не больше $N$, и, если равняется N, то $(n_1 , . . . , n_k , N ) \in SUBSET-SUM$. Иначе же оптимального подмножества не существует и $(n_1 , . . . , n_k , N ) \not\in SUBSET-SUM$.

Таким образом, с помощью полиномиального сведения мы научились решать задачу $SUBSET-SUM$ c помощью нашей задачи, т.е. с некоторым полиномиальным сведением мы можем решать любую задачу из класса $NP$ с помощью нашей.

Таким образом, мы обосновали уместность рассмотрения приближённых решений для данной задачи. Далее рассмотрим так называемое псевдополиномиальное решение. 


\section{Псевдополиномиальное решение $O(nW)$}

	% TODO : сделать определение читаемым
	\begin{definition}
		Пусть в постановку задачи входит числовой параметр n (не количественный) и алгоритм работает полиномиальное время от самого n. Тогда такой алгоритм называется псевдополиномиальным.
	\end{definition}
	В частности, для текущей задачи не известно полиномиального решения (т.е. такого, которое работает за полиномиальное от размера входа время, в частности, для числового параметра N размером входа будет $\log{N}$ ), но известно псевдополиномиальное решение.
	
	\subsection{Алгоритм}
	
	Пусть исходные объекты задачи пронумерованы числами $1..n$, W - ограничение на размер рюкзака. Применим метод динамического программирования:
	
	knapsack\_pseudopolynomial
\begin{enumerate}
	\item Инициализируем матрицу A размера (n, W) нулями.
	\item for i in 1 .. n: \\
		for s in 1 .. W: \\
		A[i, s] := A[i - 1, s] \\
		if (w(i) <= s) and (A[i, s] > A[i - 1, s - w(i)] + c(i)): \\
			A[i, s] := A[i - 1, s - w(i)]] + c(i)
	\item вернуть A[n, W], если нужна стоимость и/или восстановить подмножество за $O(nW)$ по таблице A из ячейки A[n, W] (TODO: написать, как)
	
% TODO написать восстановление ответа в ДП

\end{enumerate}
	
	
	\subsection{Доказательство}
	
	Докажем по индукции, что $A[i, s]$ - максимальная стоимость предметов, которые поместятся в рюкзак размера s, если использовать только предметы с номерами 1..i, назовём это подзадачей $[i, s]$ нашей задачи.
	
	База индукции: $\forall x \in N: A[0, x] = A[x, 0] = 0$. Очевидно, она выполнена, в рюкзак нулевого размера ничего нельзя положить (в условии все веса и стоимости строго положительны). С другой стороны, если предметов нет, то положить в рюкзак нечего.
	
	Переход: пусть $\forall 0 < j \leq i: \forall 0 < p \leq s : ((j, p) \neq (i, s)) \rightarrow A[j, p]$ вычислено корректно. Докажем, что $A[i, s]$ вычисленное из подсчитанных значений как алгоритме корректно. 
	
	Заметим, что оптимальный набор не обязательно единственен, например, для рюкзака размера 2 и предметами с массой и стоимостью 1, 1 и 2 можно положить как два предмета веса 1, так и один веса 2. 
	
	Рассмотрим множество оптимальных наборов для подзадачи $[i, s]$. Выполнен хотя бы один из двух вариантов:
	
	\begin{itemize}
		\item Существует оптимальный набор, в котором лежит предмет с номером $i$. Тогда $A[i, s] = A[i - 1, s - w(i)] + c(i)$ и $A[i, s] \geq A[i - 1, s]$. Первое утверждение прямо следует из того, что оптимальность набора гарантирует оптимальность поднабора. Иначе поднабор можно улучшить и получить противоречие с оптимальностью набора. Отрицание второго условия означает, что существует набор без предмета с номером $i$ лучше нашего и приводит к противоречию.
		\item Существует оптимальный набор, в котором не лежит предмет с номером $i$. Аналогично получаем, что $A[i, s] \geq A[i - 1, s - w(i)] + c(i)$ (если $s \geq w(i)$) и $A[i, s] = A[i - 1, s]$.
	\end{itemize}
	
	Таким образом, наш алгоритм, который по-сути выбирает максимум из двух величин $A[i, s] = max(A[i - 1, s], A[i - 1, s - w(i)] + c(i))$ (если обе существуют - иначе возможен только один вариант $A[i, s] = A[i - 1, s]$), вычисляет оптимальное значение в обоих случаях. 
	
	Итого, корректность $A[i, s]$ доказана по индукции для всех $ 0 \leq i \leq n$, $0 \leq s \leq W$, в том числе и для $A[n, W]$. Решение, очевидно, работает за $O(nW)$.


\section{Псевдополиномиальное решение $O(nC)$}
	\subsection{Алгоритм}
	
	knapsack\_pseudopolynomial\_two
	\begin{enumerate}
		\item $C = \sum\limits_{i = 1}^{n} {c(i)}$
		\item Инициализируем матрицу $A$ размера (n, С) символом $+\infty$, который будем считать большим любого числа.
		\item $A[0, 0] := 0$
		\item for i in 1..n: \\
			for s in 1..C: \\
			A[i, s] = A[i - 1, s] \\
			if ($s \geq c(i)$) and ($A[i - 1, s - c(i)] + w(i) \leq min(W, A[i, s]$)): \\
				A[i, s] := A[i - 1, s - c(i)] + w(i)
		\item $k := argmax_{k}(A[n, k] < +\infty)$
		\item вернуть k, если нужна стоимость и/или восстановить подмножество за $O(nW)$ по таблице A из ячейки A[n, k] (TODO: написать, как)
			
			% TODO написать восстановление ответа в ДП
	\end{enumerate}
	
	\subsection{Доказательство}
	
	Докажем по индукции, что $A[i, s]$ - минимальный вес подмножества предметов, которые можно помесить в рюкзак или $+\infty$, если такого нет, что использованы только предметы с номерами $1..i$ и их суммарная стоимость равна $s$.
	
	База индукции: $A[0, 0] = 0$ - пустое множество предметов оптимально.
	$\forall x > 0: A[0, x] = +\infty$ - из пустого множества предметов нельзя выбрать подмножество с положительной стоимостью.
	
	Переход: пусть $\forall 0 < j \leq i: \forall 0 < p \leq s : ((j, p) \neq (i, s)) \rightarrow A[j, p]$ вычислено корректно. Докажем, что $A[i, s]$ вычисленное из подсчитанных значений как алгоритме корректно.
	
	Возможны два случая (хотя бы один из них выполнен, возможно, оба):
	
	\begin{itemize}
		\item 
	Пусть существует оптимальный (в смысле $A[i, s]$ как минимума) набор предметов, содержащий предмет с номером $i$. Тогда $A[i, s] = A[i, s - c(i)] + w(i)$, т.к. из оптимальности набора следует оптимальность поднабора и $A[i, s] \leq A[i - 1, s]$, иначе получим противоречие с оптимальностью.
	
		\item 
	Пусть существует оптимальный набор предметов, не содержащий предмет с номером $i$. Тогда аналогично: $A[i, s] = A[i-1, s]$ и $A[i, s] \leq A[i-1, s - c(i)] + w(i)$.
	
	\end{itemize}

	Таким образом, наш алгоритм, который по-сути выбирает минимум из двух величин $A[i, s] = min(A[i - 1, s], A[i - 1, s - c(i)] + w(i))$ (если обе допустимы, т.е. $A[i - 1, s - c(i)] + w(i) \leq C$, иначе $A[i, s] = A[i-1, s]$), вычисляет оптимальное значение в обоих случаях. 
	
	Итого, корректность $A[i, s]$ доказана по индукции для всех $ 0 \leq i \leq n$, $0 \leq s \leq W$. По значениям $A[i, s]$, перебирая оптимальную суммарную стоимость $s \in 0..C$ можно восстановить ответ в задаче, достаточно просто найти $A[n, s] \neq +\infty$ с наибольшим значением $s$. Значения в таблице $A$ вычисляются за $O(nC)$, поиск наибольшего значения работает за $O(C)$, восстановление оптимального набора за $O(nC)$. Итого, решение работает за $O(nC)$.
\section{Полиномиальное приближение}
	\subsection{Алгоритм}

	knapsack\_polynomial\_estimation:
\begin{enumerate}
	\item $P := max(c(x) | w(x) \leq W)$ (вообще говоря, предметы, которые не помещаются в пустой рюкзак можно выкинуть на этапе формулировки задачи)
	\item $K := \frac{\varepsilon P}{k}$
	\item $c_{zipped}(x) := \lfloor \frac{c(x)}{K} \rfloor $
	\item Найти оптимальное подмножество $M^*$ для задачи со стоимостями $c_{zipped}(x)$ псевдополиномиальным алгоритмом за $O(nC)$ и вернуть его.
\end{enumerate}

	\subsection{Доказательство}
	
	Пусть $M$ - произвольное множество предметов.
	
	Обозначим $cost(M) : = \sum\limits_{x \in M} c(x)$,  $cost_{zipped}(M) : = \sum\limits_{x \in M} c_{zipped}(x)$
	
	Пусть $M^*$ - множество, которое было найдено псевдополиномиальным алгоритмом, а оптимальное множество предметов в задаче $O$.
	
	Тогда $K cost_{zipped}(M^*) \geq cost(O) -  nK$. Действительно, если бы мы не округляли веса до целых и нашли оптимальное решение, ты получили бы $ cost_{zipped} \equiv \frac{cost}{K}$. Однако, из-за округления вниз имеем  $\forall i: c_{zipped}(i) \leq \frac{c(i)}{K} - 1$, в частности $cost_{zipped}(M^*) \geq cost_{zipped}(O) \geq \frac{cost(O)}{K} - n$ (второе неравенство получается суммированием неравенств для каждого предмета набора $O$, а первое следует из оптимальности $M^*$). Умножая неравенство на $K$, получим требуемое неравенство.
	
	Заметим, что, если в оптимальном наборе O есть хотя бы один предмет, то 
	$cost(O) \geq P = max(c(x) | w(x) \leq W)$. Заметим, что это верно и если оптимальный набор пустой.
	
	Тогда $cost(M^*) \geq $$ K cost_{zipped} (M^*) \geq $$ cost(O) -  nK $$= cost(O) - \varepsilon P $$ \geq cost(O) - \varepsilon cost(O) $$ = (1 - \varepsilon) cost(O)$
	
	Полученное утверждение в точности есть доказываемое.
	
	
	
	
	
	\subsection{Работа на реальных данных}
	
\end{document}